# ESP32 Robot Arm Project

Проект для управления робо-рукой с тремя сервоприводами через драйвер TB6612FNG с использованием ESP32 и Bluetooth Low Energy.

## Структура проекта

```
esp32_robo_arm/
├── platformio.ini              # Конфигурация PlatformIO
├── src/
│   └── main.cpp                # Основной код программы с BLE
├── tests/
│   └── test_duration.py        # Тесты функциональности duration
├── sequences/
│   ├── robot_arm_library.py   # Библиотека команд для последовательностей
│   ├── algorithm_1.py          # Последовательность 1: Все моторы вперед 5с + поочередная остановка
│   ├── motor_calibration.py    # Модуль калибровки моторов
│   ├── calibrated_robot_arm.py # Высокоуровневый контроллер с калибровкой
│   ├── example_calibrated.py   # Примеры использования откалиброванной робо-руки
│   └── README.md               # Документация последовательностей
├── calibrate.py                # Скрипт калибровки моторов
├── robot_arm_controller.py     # Python скрипт для управления с Mac
├── requirements.txt            # Python зависимости
├── .gitignore                  # Исключения для Git
└── README.md                   # Этот файл
```

## Подключение

### TB6612FNG к ESP32:

- **PWMA** → GPIO 18 (M1_PWM)
- **AIN1** → GPIO 16 (M1_IN1)
- **AIN2** → GPIO 17 (M1_IN2)
- **PWMB** → GPIO 19 (M2_PWM)
- **BIN1** → GPIO 21 (M2_IN1)
- **BIN2** → GPIO 22 (M2_IN2)
- **PWMC** → GPIO 23 (M3_PWM)
- **CIN1** → GPIO 25 (M3_IN1)
- **CIN2** → GPIO 26 (M3_IN2)
- **STBY** → GPIO 27 (STBY)

## Функциональность

Программа управляет тремя сервоприводами робо-руки через Bluetooth Low Energy:

1. **M1** - сервопривод основания (базовый поворот)
2. **M2** - сервопривод плеча (подъем/опускание)
3. **M3** - сервопривод предплечья (сгибание/разгибание)

### Логика работы:

- **BLE сервер** создает точку доступа "ESP32-RobotArm"
- **JSON команды** принимаются через BLE характеристику
- **Индивидуальное управление** каждым мотором независимо
- **Направление и скорость** задаются для каждого мотора отдельно
- **Автоматическая остановка по времени** - моторы могут работать заданное количество миллисекунд
- **Автоматическая остановка** всех моторов при отключении BLE
- Используется PWM частота 20 кГц для плавной работы сервоприводов

### Формат JSON команд:

```json
{
  "motor": 0, // 0, 1, 2 для M1, M2, M3
  "direction": "forward", // "forward" или "backward"
  "speed": 150, // 0-255
  "duration": 2000 // время работы в миллисекундах (опционально)
}
```

**Примечание:** Параметр `duration` опциональный. Если не указан, мотор работает бесконечно до получения новой команды или команды остановки.

## Сборка и загрузка

### Через PlatformIO:

```bash
# Сборка проекта
pio run

# Загрузка на ESP32
pio run --target upload

# Мониторинг серийного порта
pio device monitor
```

### Через Arduino IDE:

Просто откройте файл `src/main.cpp` в Arduino IDE и загрузите на ESP32.

## Управление через Python скрипт

### Установка зависимостей:

```bash
# Создание виртуального окружения (рекомендуется для macOS)
python3 -m venv venv

# Активация виртуального окружения
source venv/bin/activate

# Установка Python библиотеки для BLE
python -m pip install bleak
```

### Использование:

```bash
# Активация виртуального окружения (если еще не активировано)
source venv/bin/activate

# Поиск устройства ESP32
python robot_arm_controller.py scan

# Подключение и интерактивный режим
python robot_arm_controller.py connect

# Демонстрационная последовательность
python robot_arm_controller.py demo
```

### Интерактивные команды:

После подключения доступны следующие команды:

- `m <motor> <direction> <speed> [duration]` - Управление мотором
  - `motor`: 0, 1, 2 (M1, M2, M3)
  - `direction`: forward, backward
  - `speed`: 0-255
  - `duration`: время работы в миллисекундах (опционально)
- `stop` - Остановить все моторы
- `help` - Показать справку
- `quit` - Выход

### Примеры команд:

```bash
# M1 вперед со скоростью 150 (бесконечно)
m 0 forward 150

# M2 назад со скоростью 100 на 2 секунды
m 1 backward 100 2000

# M3 вперед на максимальной скорости на 1.5 секунды
m 2 forward 255 1500

# Остановить все моторы
stop
```

## Тестирование

Для проверки функциональности `duration` запустите тест:

```bash
# Активация виртуального окружения
source venv/bin/activate

# Запуск теста функциональности duration
python tests/test_duration.py
```

Тест проверяет:

- Команды без `duration` (бесконечная работа)
- Команды с `duration` (автоматическая остановка)
- Несколько моторов с разным временем работы
- Остановку всех моторов

## Последовательности управления

Для создания сложных последовательностей движений используйте готовые скрипты из папки `sequences/`:

### Доступные последовательности:

- **Sequence 1** - Все моторы вперед 5с + поочередная остановка
  ```bash
  python sequences/algorithm_1.py
  ```

### Библиотека команд:

Используйте `robot_arm_library.py` для создания собственных последовательностей:

```python
from sequences.robot_arm_library import RobotArmLibrary

async def my_sequence():
    robot = RobotArmLibrary()
    await robot.connect()

    # Все моторы вперед на 3 секунды
    await robot.all_motors_forward(speed=150, duration=3000)
    await robot.wait(3.5)

    # Поочередная остановка
    for motor in range(3):
        await robot.motor_stop(motor)
        await robot.wait(2)

    await robot.disconnect()
```

Подробная документация: [sequences/README.md](sequences/README.md)

## Калибровка моторов

Перед использованием робо-руки рекомендуется откалибровать моторы для определения их рабочих диапазонов:

### Запуск калибровки:

```bash
python calibrate.py
```

### Процесс калибровки:

1. **Выберите мотор** для калибровки (0, 1, 2)
2. **Движение к минимальному положению** - мотор вращается вперед, вы нажимаете Enter когда рука достигнет крайнего положения
3. **Движение к максимальному положению** - мотор вращается назад, вы нажимаете Enter когда рука достигнет другого крайнего положения
4. **Возврат в исходное положение** - для измерения полного времени прохода
5. **Сохранение данных** - результаты калибровки сохраняются в `motor_calibration.json`

### Команды калибровки:

- `calibrate 0` - Калибровка мотора 0
- `calibrate 1` - Калибровка мотора 1
- `calibrate 2` - Калибровка мотора 2
- `status` - Показать статус калибровки всех моторов
- `save` - Сохранить данные калибровки
- `quit` - Выход из режима калибровки

### Файл калибровки:

Данные сохраняются в `motor_calibration.json`:

```json
{
  "0": {
    "calibrated": true,
    "calibration_date": "2024-01-15T10:30:00",
    "forward_time": 2.5,
    "backward_time": 2.3,
    "speed": 150,
    "average_travel_time": 2.4
  }
}
```

## Высокоуровневый контроллер

После калибровки моторов можно использовать `CalibratedRobotArm` для удобного управления:

### Запуск демо:

```bash
python sequences/example_calibrated.py
```

### Интерактивный режим:

```bash
python sequences/example_calibrated.py interactive
```

### Основные возможности:

#### Точное позиционирование:

```python
from sequences.calibrated_robot_arm import CalibratedRobotArm

robot = CalibratedRobotArm()
await robot.connect()

# Движение на конкретный процент от диапазона
await robot.move_to_percentage(0, 0.0)    # Минимум
await robot.move_to_percentage(0, 0.5)    # Середина
await robot.move_to_percentage(0, 1.0)    # Максимум
await robot.move_to_percentage(0, 0.25)   # 25% от диапазона
```

#### Предустановленные позиции:

```python
# Доступные позиции: home, pick, place, rest, extended, retracted
await robot.move_to_position("home")      # Домашняя позиция
await robot.move_to_position("pick")     # Позиция для захвата
await robot.move_to_position("place")    # Позиция для размещения
```

#### Плавные движения:

```python
# Плавное движение от 0% до 100% за 20 шагов
await robot.smooth_move(0, 0.0, 1.0, steps=20, step_delay=0.1)
```

#### Готовые последовательности:

```python
await robot.pick_and_place_sequence()    # Взять → переместить → положить
await robot.wave_sequence()              # Махание рукой
```

### Команды интерактивного режима:

- `move 0 0.5` - Движение мотора 0 на 50%
- `position home` - Переход в позицию "home"
- `smooth 0 0.0 1.0` - Плавное движение мотора 0 от 0% до 100%
- `pickplace` - Запуск последовательности pick and place
- `wave` - Запуск последовательности махания
- `status` - Показать статус калибровки
- `positions` - Показать доступные позиции

## Требования

### Аппаратные:

- ESP32 Dev Module
- TB6612FNG Motor Driver
- 3 сервопривода для робо-руки
- Блок питания для сервоприводов
- Соединительные провода

### Программные:

- PlatformIO или Arduino IDE
- Python 3.7+ (для управления с Mac)
- Библиотека `bleak` для Python

## Примечания

- Проект использует ESP32 Arduino framework 3.x
- PWM настроен на частоту 20 кГц для плавной работы сервоприводов
- Все комментарии в коде на английском языке согласно требованиям
- BLE сервер автоматически переподключается при отключении клиента
- JSON команды валидируются на ESP32 перед выполнением
- Автоматическая остановка всех моторов при потере BLE соединения
